// ==========================================
// Alkyl Language - RPG Battle Simulator
// Demonstrating Alkyl's core features
// ==========================================

import "std"; 
link m; // standard math library

extern double sin(double);
extern int system(string cmd);

// 1. Typedefs and Defines
define dict as typedef;
dict string as char*;

// Global variable to demonstrate shadowing
char global_env[] = "Dungeon Entrance";

// 2. Namespaces
namespace MathUtils {
    int max(int a, int b) {
        if (a > b) { return a; }
        return b;
    }
    
    int min(int a, int b) {
        if (a < b) { return a; }
        return b;
    }

    double get_scaling_factor(int level) {
        // Using standard C math library via link m
        let factor = sin((double) level);
        return 1.0 + factor;
    }
}

// 3. Enums
enum Element [
    Physical,
    Fire,
    Ice,
    Lightning,
    Poison,
    Holy
]

enum StatusEffect [
    Normal,
    Burned,
    Frozen,
    Paralyzed
]

// 4. Traits (Classes acting as interfaces/components)
open class Logger {
    void log_combat(string actor, string action, int value) {
        print "[COMBAT LOG]: %s used %s. Effect scale: %d\n", actor, action, value;
    }
    
    void log_system(string msg) {
        print "[SYSTEM]: %s\n", msg;
    }
}

open class Inventory {
    int potions = 3;
    int elixirs = 1;

    void use_potion() {
        if (this.potions > 0) {
            this.potions--;
            print ">> Used a potion! %d remaining.\n", this.potions;
        } else {
            print ">> No potions left!\n";
        }
    }
}

// 5. Base Class with Trait Composition
open class Entity has Logger {
    string name = "Unknown";
    int hp = 100;
    int max_hp = 100;
    int attack_power = 10;
    int defense = 5;
    
    void take_damage(int amount) {
        int actual = MathUtils.max(1, amount - this.defense);
        this.hp = MathUtils.max(0, this.hp - actual);
        print "%s takes %d damage! (HP: %d/%d)\n", this.name, actual, this.hp, this.max_hp;
    }

    void heal(int amount) {
        this.hp = MathUtils.min(this.max_hp, this.hp + amount);
        print "%s heals %d HP! (HP: %d/%d)\n", this.name, amount, this.hp, this.max_hp;
    }
}

// 6. Inheritance & Multiple Traits
open class Hero is Entity has Inventory {
    int mana = 50;
    int max_mana = 50;
    int level = 1;

    void cast_spell(int spell_type) {
        if (this.mana >= 15) {
            this.mana = this.mana - 15;
            this[Logger].log_combat(this.name, "Magic Spell", 15);
            print "%s casts a powerful spell!\n", this.name;
        } else {
            print "%s lacks the mana to cast!\n", this.name;
        }
    }

    void show_status() {
        print "\n=== HERO STATUS ===\n";
        print "Name: %s | Lvl: %d\n", this.name, this.level;
        print "HP: %d/%d | MP: %d/%d\n", this.hp, this.max_hp, this.mana, this.max_mana;
        print "Potions: %d\n", this.potions;
        print "===================\n";
    }
}

open class Monster is Entity {
    int element_type = Element.Fire;
    int status = StatusEffect.Normal;

    void enrage() {
        this.attack_power = this.attack_power + 10;
        this.defense = this.defense - 5;
        this[Logger].log_system(this.name + " became ENRAGED!");
    }

    void show_status() {
        print "\n=== MONSTER STATUS ===\n";
        print "Name: %s\n", this.name;
        print "HP: %d/%d\n", this.hp, this.max_hp;
        // Enum string conversion mapping
        print "Element: %s | Condition: %s\n", Element[this.element_type], StatusEffect[this.status];
        print "======================\n";
    }
}

// 7. Function Overloading
void scan_target(Hero h) {
    print "Scanning Hero: %s. Vital signs strong.\n", h.name;
}

void scan_target(Monster m) {
    print "Scanning Monster: %s. Weakness: Ice.\n", m.name;
}

void scan_target(string generic) {
    print "Scanning environment: %s\n", generic;
}

// 8. Main Entry Point
int main() {
    print "========================================\n";
    print "      WELCOME TO ALKYL DUNGEONS\n";
    print "========================================\n\n";

    // Shadowing test: overriding global_env
    let global_env = "Boss Room"; 
    print "Current Location: %s\n", global_env;
    print "Environment variable type: %s\n\n", typeof(global_env);

    // Instantiation mapping fields sequentially 
    // Hero: Entity(name, hp, max, atk, def) + Hero(mana, max_mana, level)
    let arthur = Hero("Arthur Pendragon", 200, 200, 25, 15, 100, 100, 5);
    
    // Monster: Entity(name, hp, max, atk, def) + Monster(element, status)
    let dragon = Monster("Ignis The Dread", 400, 400, 35, 10, Element.Fire, StatusEffect.Normal);

    arthur.show_status();
    dragon.show_status();

    // Arrays & String Prefixes
    char equipment[] = ['E','x','c','a','l','i','b','u','r','\0'];
    let rank = c"S-Class"; // char* prefix
    print "\nArthur's Weapon: %s (Rank: %s)\n\n", equipment, rank;

    print "--- BATTLE COMMENCES ---\n";

    mut int turn = 1;
    mut int battle_active = 1;

    // Control Flow: While loop
    while (battle_active > 0) {
        print "\n[ Turn %d ]\n", turn;

        // Simulated user action logic
        let action = turn % 4; 

        // Switch Statement with Fallthrough (leak case)
        switch (action) {
            case 1:
                print "> Arthur attacks with %s!\n", equipment;
                dragon.take_damage(arthur.attack_power + 10);
            case 2:
                print "> Arthur prepares a spell!\n";
                arthur.cast_spell(1);
                dragon.take_damage(40);
            leak case 3:
                // Fallthrough triggers a buff AND heals
                print "> Arthur finds an opening!\n";
                arthur.attack_power++; 
            case 0:
                print "> Arthur falls back to defend and heal!\n";
                arthur[Inventory].use_potion();
                arthur.heal(40);
        }

        if (dragon.hp <= 0) {
            print "\n%s has been slain! VICTORY!\n", dragon.name;
            battle_active = 0;
        }

        // Enemy Turn
        if (battle_active > 0) {
            if (turn == 3) {
                dragon.enrage();
            }

            print "\n> %s retaliates!\n", dragon.name;
            arthur.take_damage(dragon.attack_power);
            
            if (arthur.hp <= 0) {
                print "\n%s has fallen... GAME OVER.\n", arthur.name;
                battle_active = 0;
            }
        }

        turn++;
        
        // Timeout safeguard
        if (turn > 7) {
            print "\n[SYSTEM] The battle ended in a draw.\n";
            battle_active = 0;
        }
    }

    print "\n--- BATTLE END ---\n";
    
    // Looping & String Concatenation 
    print "Experience gained: \n";
    string xp_bar = "[";
    loop 15 {
        xp_bar = xp_bar + "=";
    }
    xp_bar = xp_bar + "]";
    print "%s 1500 XP\n", xp_bar;

    // Implicit Casting and Postfix Operators
    double win_ratio = 1; // cast int to double
    int score = 99.5;     // truncate double to int
    print "Win Ratio: %lf | Final Score: %d\n", win_ratio, score;
    
    // Testing dynamic memory tracking syntax
    char *session_log = "Session finalized successfully.";
    print "%s\n", session_log;
    
    // Freeing memory keyword 
    free session_log; 
    
    return 0;
}
